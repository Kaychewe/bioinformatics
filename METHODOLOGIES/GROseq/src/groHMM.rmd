---
title: "Pausing Index Noteboook"
author: Kasonde Chewe
output: html_notebook
---

# 1. Transcript Identification with groHMM 
The groHMM package includes functions for identifying actively transcribed regions, estimating gene expression levels, and detecting transcription start sites and transcriptional pausing. It utilizes hidden Markov models (HMMs) and other statistical techniques to analyze the data and infer transcriptional activity.

```{r}
suppressPackageStartupMessages(library(TxDb.Hsapiens.UCSC.hg19.knownGene))
suppressPackageStartupMessages(library(BSgenome.Hsapiens.UCSC.hg19))
suppressPackageStartupMessages(library(GenomicAlignments)) 
suppressPackageStartupMessages(library(GenomicFeatures))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(org.Hs.eg.db)) # genome-build unspecified
suppressPackageStartupMessages(library(edgeR))
suppressPackageStartupMessages(library(groHMM))
```


```{r}
# Set multicore options
options(mc.cores = parallel::detectCores())

# Loading Additional Helper Functions -> written elsewhere for portability
source("~/final-project-dir/GRO-SEQ/scripts/helpers/groSeqFunctions.R")

# References 
# 1. https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html
# 2. ..
```


```{r}
# Load GRO-seq data as bam files 
ctrl_r1_path <- "~/final-project-dir/GRO-SEQ/mapped/Ctr_r1.sorted.bam"
ctrl_r2_path <- "~/final-project-dir/GRO-SEQ/mapped/Ctr_r2.sorted.bam"
ko_r1_path <- "~/final-project-dir/GRO-SEQ/mapped/KO_r1.sorted.bam"
ko_r2_path <- "~/final-project-dir/GRO-SEQ/mapped/KO_r2.sorted.bam"

# 1. Load BAM files for each replicate
ctrl_r1_gr <- load_bam(ctrl_r1_path)
ctrl_r2_gr <- load_bam(ctrl_r2_path)
ko_r1_gr <- load_bam(ko_r1_path)
ko_r2_gr <- load_bam(ko_r2_path)
```


## Description of Dataset
The data set includes 4 groSeq sequencing samples, 2 control replicates and 2 knockout conditions
(for NELF-subunit E or NELFE). The sequencing samples have the following information 

end=single-end 
format=bam 
genome=hg19
annotations-source=ncbi


```{r}
# 2. Pre-processing bams to GRanges objects to keep only standard chromosomes
ctrl_r1_gr <- keepStandardChromosomes(ctrl_r1_gr, pruning.mode="coarse")
ctrl_r2_gr <- keepStandardChromosomes(ctrl_r2_gr, pruning.mode="coarse")
ko_r1_gr <- keepStandardChromosomes(ko_r1_gr, pruning.mode="coarse")
ko_r2_gr <- keepStandardChromosomes(ko_r2_gr, pruning.mode="coarse")

# Further prune chrX, chrY, chrM sequence data from GRange objects 
all_chr <- seqlevels(ctrl_r1_gr)
exclude_chr <- c("chrM", "chrX", "chrY")
keep_chr <- setdiff(all_chr, exclude_chr)

seqlevels(ctrl_r1_gr, pruning.mode="coarse") <- keep_chr
seqlevels(ctrl_r2_gr, pruning.mode="coarse") <- keep_chr
seqlevels(ko_r1_gr, pruning.mode="coarse") <- keep_chr
seqlevels(ko_r2_gr, pruning.mode="coarse") <- keep_chr

```



# Transcript Calling
In groHMM, transcribed regions are detected de novo using a two-state hidden Markov model
(HMM). The model takes GRO-seq read counts as input across the genome and divides
the genome into “transcribed” and “non-transcribed” state as shown in Figure 1. First, a
single read set is generated by combining all samples for each time point. This combined
approach improves sensitivity for transcripts with low expression levels. Combined reads are
used to train the model parameters using the Baum-Welch Expectation Maximization (EM)
algorithm. Each strand is modeled separately dividing the genome into non-overlapping 50
bp windows classified as either state.

```{r}
# 3. Transcript Calling
Sall <- sort(c(ctrl_r1_gr, ctrl_r2_gr,ko_r1_gr, ko_r2_gr))
# hmmResult <- detectTranscripts(Sall, LtProbB=-200, UTS=5, threshold=1)

# Pre-load from prior run, Baulm Welch Algorithm, maximum likelihood estimation..
hmmResult <- readRDS(file = "~/final-project-dir/GRO-SEQ/groHMM/hmmResult19.rds")
txHMM <- hmmResult$transcripts
seqlevels(txHMM, pruning.mode="coarse") <- keep_chr # debug- this step is redundance, remove from future use cases
head(txHMM)
```

```{r}
# Load Transcript Annotations from the Tx Database
kgdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
kgAll <- transcripts(kgdb, columns=c("gene_id", "tx_id", "tx_name"))
seqlevels(kgAll) <- seqlevelsInUse(kgAll)
kgAll <- keepStandardChromosomes(kgAll, pruning.mode="coarse")
seqlevels(kgAll, pruning.mode="coarse") <- keep_chr 

# note: ensure that kgAll has only 22 sequence levels 
```

```{r}
# 6. Collapse overlapping annotations
# kgConsensus <- makeConsensusAnnotations(kgAll, keytype="gene_id", mc.cores=getOption("mc.cores")) 
# saveRDS(kgConsensus, file = "~/final-project-dir/GRO-SEQ/groHMM/kgConsensus38.rds") 

kgConsensus <- readRDS(file = "~/final-project-dir/GRO-SEQ/groHMM/kgConsensus19.rds")
kgConsensus <- trim(kgConsensus) 
map <- AnnotationDbi::select(org.Hs.eg.db,
                             keys=unlist(mcols(kgConsensus)$gene_id),
                             columns=c("SYMBOL"), keytype=c("ENTREZID"))
```


```{r}
mcols(kgConsensus)$symbol <- map$SYMBOL
mcols(kgConsensus)$type <- "gene"
e <- evaluateHMMInAnnotations(txHMM, kgConsensus) 
e$eval
```


```{r}
# 7. Visualizing TP, FP, TN and FN
getExpressedAnnotations <- function(features, reads) {
  fLimit <- limitToXkb(features)
  count <- countOverlaps(fLimit, reads)
  features <- features[count!=0,]
  return(features[(quantile(width(features), .05) < width(features))
  & (width(features) < quantile(width(features), .95)),])}
conExpressed <- getExpressedAnnotations(features=kgConsensus,reads=Sall)


```


```{r}
# rewritten with ggplots for pretty graphics 
# groHMM 
td <- getTxDensity(txHMM, conExpressed, mc.cores=getOption("mc.cores"))
u <- par("usr")
lines(c(u[1], 0, 0, 1000, 1000, u[2]), c(0,0,u[4]-.04,u[4]-.04,0,0),
      col="red")
legend("topright", lty=c(1,1), col=c(2,1), c("ideal", "groHMM"))
text(c(-500,500), c(.05,.5), c("FivePrimeFP", "TP"))
```


```{r}

# 9. Repairing Transcript Calling with Annotations
# bPlus <- breakTranscriptsOnGenes(txHMM, kgConsensus, strand="+")
# bMinus <- breakTranscriptsOnGenes(txHMM, kgConsensus, strand="-")
# txBroken <- c(bPlus, bMinus)
# txFinal <- combineTranscripts(txBroken, kgConsensus)

# Save RDS object
saveRDS(txFinal, file = "~/final-project-dir/GRO-SEQ/groHMM/txFinal19.rds") 

# Read txFinal as RDS 
# txFinal <- readRDS(file = "~/final-project-dir/GRO-SEQ/groHMM/txFinal19.rds")
```

```{r}

```

```{r}
# Total number of transcripts
total_transcripts <- length(txFinal)
cat("Total Transcripts Identified:", total_transcripts, "\n")


# Count of transcripts by chromosome 
cat("\nNumber of Transcripts per Chromosome: \n")
transcripts_per_chromosome <- table(seqnames(txFinal))
print(transcripts_per_chromosome)


cat("\nNumber of Transcripts per Strand:\n")
transcripts_per_strand <- table(strand(txFinal))
print(transcripts_per_strand)

```

```{r}
library(edgeR)
txLimit <- limitToXkb(txFinal)
ctr1 <- countOverlaps(txLimit, ctrl_r1_gr)
ctr2 <- countOverlaps(txLimit, ctrl_r2_gr)
ko1 <- countOverlaps(txLimit, ko_r1_gr)
ko2 <- countOverlaps(txLimit, ko_r2_gr)

pcounts <- as.matrix(data.frame(ctr1, ctr2, ko1, ko2))
group <- factor(c("ev", "ev", "ko", "ko"))
lib.size <- c(NROW(ctr1), NROW(ctr2), NROW(ko1), NROW(ko2))
d <- DGEList(counts=pcounts, lib.size=lib.size, group=group)
d <- estimateCommonDisp(d)
et <- exactTest(d)
de <- decideTestsDGE(et, p=0.05, adjust.method = "none", lfc = 2)
detags <- seq_len(NROW(d))[as.logical(de)]
# Number of transcripts regulated for EV
cat("up: ",sum(de==1), " down: ", sum(de==-1), "\n")
```
```{r}
plotSmear(et, de.tags=detags)
abline(h = c(-1,1), col="blue")

```
### Statistical Validation 
```{r}
#'et' is the result of  exactTest call from edgeR
# Extract p-values and adjusted p-values
p_values <- et$table$PValue
adj_p_values <- topTags(et, n=Inf)$table$adj.PVal

# Plot histogram of p-values
hist(p_values, breaks = 50, main = "Histogram of p-values", xlab = "p-value", col = "skyblue")
abline(v = 0.05, col = "red", lwd = 2)  # Add a line for the nominal significance level

# Get the top differentially expressed genes with adjusted p-values
top_genes <- topTags(et, n=Inf)  # 'n=Inf' retrieves all genes

# Extract the adjusted p-values
adj_p_values <- top_genes$table$FDR

# Now you can plot the histogram of adjusted p-values
hist(adj_p_values, breaks=50, main="Histogram of adjusted p-values", xlab="Adjusted p-value", col="lightgreen")
abline(v=0.05, col="red", lwd=2)


# QQ plot for p-values
qqplot(-log10(ppoints(length(p_values))), -log10(sort(p_values)), xlab = "Expected -log10(p-value)", ylab = "Observed -log10(p-value)", main = "QQ Plot of p-values")
abline(0, 1, col = "red", lwd = 2)

# QQ plot for adjusted p-values
qqplot(-log10(ppoints(length(adj_p_values))), -log10(sort(adj_p_values)), xlab = "Expected -log10(adjusted p-value)", ylab = "Observed -log10(adjusted p-value)", main = "QQ Plot of adjusted p-values")
abline(0, 1, col = "red", lwd = 2)

```
Histogram of p-values:

- The histogram shows a large number of p-values close to 1, which indicates a large number of genes are not differentially expressed.
- The peak at 1 is very common in datasets where most genes are not differentially expressed.
- The red line at the p-value threshold of 0.05 shows the typical cutoff for significance without multiple testing correction.

Histogram of adjusted p-values:

- This histogram shows that most of the adjusted p-values are close to 1, which is expected after controlling for false discovery rate (FDR).
- The tight clustering near 1 suggests that after adjustment, few genes pass the FDR threshold, indicating either a low number of differentially expressed genes or a dataset with little differential expression signal.

QQ Plot of p-values:

- The QQ plot for p-values shows the observed versus expected -log10(p-values).
- The deviation from the red line (which represents the expected distribution under the null hypothesis) at the lower end suggests that there are some genes with significant p-values.
- However, the curve starts to follow the expected line quite closely after a certain point, indicating that the majority of the p-values are consistent with the null hypothesis of no differential expression.


QQ Plot of adjusted p-values:

- This QQ plot is not showing the expected pattern. Ideally, the points should start on the red line and then deviate upwards as they represent the truly differentially expressed genes.
- The fact that all points are at the bottom indicates an issue with the adjusted p-values. They are all very close to 1, which suggests that either there's an issue with the adjustment process, or the dataset has very few differentially expressed genes.


```{r}
top_genes
gene_ids <- row.names(top_genes)
gene_info <- AnnotationDbi::select(org.Hs.eg.db, keys=gene_ids, columns=c("SYMBOL", "GENENAME"), keytype="ENTREZID")
combined_results <- cbind(gene_info, top_genes)
head(combined_results)


```


```{r}
# For ucsc knownGenes
kgChr7 <- transcripts(kgdb, filter <- list(tx_chrom = "chr7"), columns=c("gene_id", "tx_id", "tx_name"))
map <- AnnotationDbi::select(org.Hs.eg.db, keys=unique(unlist(mcols(kgChr7)$gene_id)), columns=c("SYMBOL"), keytype=c("ENTREZID"))
missing <- elementNROWS(mcols(kgChr7)[,"gene_id"]) == 0

kgChr7 <- kgChr7[!missing,]
inx <- match(unlist(mcols(kgChr7)$gene_id), map$ENTREZID)
mcols(kgChr7)$symbol <- map[inx,"SYMBOL"]

txLimit <- limitToXkb(kgChr7)
ctr1 <- countOverlaps(txLimit, ctrl_r1_gr)
ctr2 <- countOverlaps(txLimit, ctrl_r2_gr)
ko1 <- countOverlaps(txLimit, ko_r1_gr)
ko2 <- countOverlaps(txLimit, ko_r2_gr)

counts <- as.matrix(data.frame(ctr1, ctr2, ko1, ko2))
group <- factor(c("ev", "ev", "ko", "ko"))
lib.size <- c(NROW(ctr1), NROW(ctr2), NROW(ko1), NROW(ko2))
d <- DGEList(counts=counts, lib.size=lib.size, group=group)
d <- estimateCommonDisp(d)
et <- exactTest(d)
de <- decideTestsDGE(et, p=0.05, adjust.method = "none", lfc = 2)
detags <- seq_len(NROW(d))[as.logical(de)]
symbols <- mcols(kgChr7)$symbol

# Number of transcripts regulated 
cat("up: ", NROW(unique(symbols[de==1])), "\n")

cat("down: ", NROW(unique(symbols[de==-1])), "\n")
```

```{r}
plotSmear(et, de.tags=detags)
abline(h = c(-1,1), col="blue")
```


```{r}

# Combine replicates
EVm <- c(ctrl_r1_gr, ctrl_r1_gr)
KOm <- c(ko_r1_gr, ko_r2_gr)

upGenes <- kgChr7[de==1,]
expReads <- mean(c(NROW(EVm), NROW(KOm)))

# Metagene around TSS
ev0m <- runMetaGene(features=upGenes, reads=EVm, size=100, normCounts=expReads/NROW(EVm), sampling=FALSE, mc.cores=getOption("mc.cores"))
kom <- runMetaGene(features=upGenes, reads=KOm, size=100, normCounts=expReads/NROW(KOm), sampling=FALSE, mc.cores=getOption("mc.cores"))

```

```{r}

MAX <- max(c(ev0m$sense, kom$sense))
MIN <- -1*max(c(ev0m$antisense, kom$antisense))
plotMetaGene(mg=ev0m, MIN=MIN, MAX=MAX)

```
```{r}
plotMetaGene(mg=kom, MIN=MIN, MAX=MAX)
```

# Further modifications 
1. explore q-value computations, most differentially expressed genes 
2. log2FC vs log10FC of GROseq data 
3. hyperparamter tuning to minimize sum of squares error
4. Final report part-1 (transcript Identification)
3. Pol ii pausing index (PART 2 OF SCRIPT )

